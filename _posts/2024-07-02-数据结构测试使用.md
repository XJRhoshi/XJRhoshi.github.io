---
layout:     post   				    # 使用的布局（不需要改）
title:      数值计算方法 				# 标题 
subtitle:   复习 #副标题
date:       2024-07-02 				# 时间
author:     星间润 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 数学
---

注：编辑时无法使用LateX，对于图片上传仍然十分不方便，使用其他网站的图片还是更方便一些，有没有一些其他方法能够简化图片上传？

目前看来，博客的使用仅限于知识传播与复习使用。目前想到的就只有英语单词的复习，还有算法复习。只能当做一个错题本吗？


- 向量，即一组变量$𝑥=(𝑥1,𝑥2,𝑥3,⋯,𝑥𝑛)$ 


----

# 数据结构测试

4-1 计算二叉树最大的宽度

二叉树的最大宽度是指二叉树所有层中结点个数的最大值。例如：下面二叉树的宽度为4.  
![image.png](https://images.ptausercontent.com/5852a182-2912-43c0-93a6-a30e34d5c168.png)  
输入二叉树的完全前序序列建立一棵二叉树（上机作业2：二叉树的建立和遍历），编写算法计算并输出二叉树的宽度。

### 输入格式:

二叉树数据元素为单个字符且各不相同，取值范围为A~Z，a~z，二叉树可以为空。输入数据分为2行，第1行为二叉树完全前序序列字符(包括#)个数，第2行为二叉树的完全前序序列。例如，上面二叉树的输入为：ABD##FE###CG#H##I##，其中#代表为空的位置。

### 输出格式:

输出一行，二叉树的宽度（整数）

### 输入样例:

以上面的二叉树为例，输入为：

```in
19
ABD##FE###CG#H##I##
```

### 输出样例:

对于上面的输入，输出为：

```out
4
```

```c++
#include<bits/stdc++.h>

using namespace std;

typedef struct BiTNode
{
    char data;
    struct BiTNode* lchild;
    struct BiTNode* rchild;
} BiTNode, *BiTree;

BiTree CreateBiTree(BiTree &T)
{
    char ch;
    cin >> ch;
    if (ch=='#')
        T = NULL;
    else
    {
        T = (BiTree)malloc(sizeof(BiTNode));
        T->data = ch;
        CreateBiTree(T->lchild);  
        CreateBiTree(T->rchild);  
    }
    return T;
}

void widthbyPreOrder(BiTree T, int d, int* level)
{
    if(T)
    {
        level[d]++;
        widthbyPreOrder(T->lchild, d+1, level);
        widthbyPreOrder(T->rchild, d+1, level);
    }
}

int width(BiTree T, int num)
{
    int level[100];
    int i;
    for(i = 0; i<=num; i++)
        level[i] = 0;
    widthbyPreOrder(T, 1, level);
    int maxWidth = 0;
    for(int i = 1; i < 100 && level[i] >0; i++)
    {
        if(level[i]>maxWidth)
            maxWidth = level[i];
    }
    return maxWidth;
}

int main()
{
    int a;
    int solution;
    BiTree T;
    cin >> a;
    T = CreateBiTree(T);
    solution = width(T, a);
    printf("%d",solution);
    return 0;
}

```

4-2 树的同构

给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。

| ![fig1.jpg](https://images.ptausercontent.com/0c8bbacf-d64e-4c6d-8d4e-1249e33fb0b1.jpg) |
| :-------------------------------------------------------------------------------------: |
|                                           图1                                            |
|                        ![](https://images.ptausercontent.com/29)                        |
|                                           图2                                            |

现给定两棵树，请你判断它们是否是同构的。

### 输入格式:

输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数N (≤10)，即该树的结点数（此时假设结点从0到N−1编号）；随后N行，第i行对应编号第i个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。

### 输出格式:

如果两棵树是同构的，输出“Yes”，否则输出“No”。

### 输入样例1（对应图1）：

```in
8
A 1 2
B 3 4
C 5 -
D - -
E 6 -
G 7 -
F - -
H - -
8
G - 4
B 7 6
F - -
A 5 1
H - -
C 0 -
D - -
E 2 -
```

### 输出样例1:

```out
Yes
```

### 输入样例2（对应图2）：

```
8
B 5 7
F - -
A 0 3
C 6 -
H - -
D - -
G 4 -
E 1 -
8
D 6 -
B 5 -
E - -
H - -
C 0 2
G - 3
F - -
A 1 4
```

### 输出样例2:

```
No
```

```c++
#include<iostream>
#include<cstdio>

#define MAXSIZE 10

using namespace std;

typedef struct TNode
{
	char data;
	int left;
	int right;
}Tree;

Tree T1[MAXSIZE];
Tree T2[MAXSIZE];

int BuildTree(Tree T[])
{
	int N;
	scanf("%d", &N);
	int root = 0;
	if (N == 0)
        return -1;
	if (N)
	{
		int check[MAXSIZE];
		for (int i = 0; i < N; ++i)
			check[i] = 0;
		char cl, cr;
		for (int i = 0; i < N; ++i)
		{
			cin >> T[i].data >> cl >> cr;
			if (cl != '-')
			{
				T[i].left = cl - 48;
				check[T[i].left] = 1;
			}
			else
				T[i].left = -1;
			if (cr != '-')
			{
				T[i].right = cr- 48;
				check[T[i].right] = 1;
			}
			else
				T[i].right = -1;
		}
		for (int i = 0; i < N; ++i)
		{
			if (!check[i])
			{
				root = i;
				break;
			}
		}
	}
	return root;
}

bool issame(int root1,int root2)
{
	if (root1 == -1 && root2 == -1)
		return true;
	if ((root1 == -1 && root2 != -1) || (root1 != -1 && root2 == -1))
		return false;

	if (T1[root1].data != T2[root2].data)
		return false;

	if (T1[root1].left == -1 && T2[root2].left == -1)
		return issame(T1[root1].right, T2[root2].right);

	if (T1[T1[root1].left].data == T2[T2[root2].left].data)
		return issame(T1[root1].left, T2[root2].left)&&issame(T1[root1].right,T2[root2].right);
	else
		return issame(T1[root1].left, T2[root2].right)&&issame(T1[root1].right, T2[root2].left);
}
int main()
{
	int r1, r2;
	r1 = BuildTree(T1);
	r2 = BuildTree(T2);
	if (issame(r1, r2))
		printf("Yes");
	else
		printf("No");
	return 0;
}
```

